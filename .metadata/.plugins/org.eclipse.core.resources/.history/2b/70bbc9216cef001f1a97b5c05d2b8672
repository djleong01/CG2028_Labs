/*
 * asm_func.s
 *
 *  Created on: 7/2/2025
 *      Author: Hou Linxin
 */
   .syntax unified
	.cpu cortex-m4
	.fpu softvfp
	.thumb

		.global asm_func

@ Start of executable code
.section .text

@ CG/[T]EE2028 Assignment 1, Sem 2, AY 2024/25
@ (c) ECE NUS, 2025

@ Write Student 1’s Name here: Zhang Yijian
@ Write Student 2’s Name here: Leong Deng Jun

@ Look-up table for registers:

@ R0 ptr to first element in 2D array for building slots
@ R1 ptr to array for entry events
@ R2 ptr to array for exit events
@ R3 ptr 2D array for results
@ R4 # of elements (F*S)
@ R5 for-loop counter i
@ R6 holding the loop limit (5 - # of entry events)
@ R7 floor - curr floor pointer
@ R8 section - curr section pointer
@ R9 cars - # of cars at each entry event
@ R10 available - # of available floors
@ R11 parking[floor][sec]
@ R12
@ R13
@ R14 link register
@ ...

@ Offset = ((i * S) + j) *4

@ write your program from here:

.equ SECTION_MAX, 12
// return value from asm back to C program, R0 register is used
asm_func:
	LDR R4, [R3]		// Load value of result[0][0], which is F
	LDR R5, [R3, #4]	// Load value of result[0][1], which is S
	MUL R4, R4, R5		// Multiply to get # of elements in the array

	PUSH {R4}
	PUSH {R5}			// push R4, R5 to the stack

	MOV	R5, #0			// R5 serving as loop counter i, init to 0
	MOV R6, #5			// R6 holding loop limit, which is 5 (# of entering events)
	MOV R7, #0			// init R7 (floor) to 0
	MOV R8, #0			// init R8 (section) to 0

FIRST_FOR_LOOP:
	CMP R5, R6			// compare i with 5
	BGE FIRST_LOOP_EXIT		// if i>=5, exit loop

	LDR	R9, [R1, R5, LSL #2]	// load entry element from R1 address + (i*4) into R7

	B WHILE_LOOP		// branch to while loop

	ADD R5, R5, #1		// i++
	B FIRST_FOR_LOOP	// jump back to start of the loop

WHILE_LOOP:
	CMP R9, #0			// compare #cars remaining for that event >0
	BLE WHILE_LOOP_EXIT	// if cars <= 0, branch back to the main for-loop

	CMP R7, #0			// compare floors to confirm there are available floors
	BGE WHILE_LOOP_EXIT	// if floors >= 0, branch back to the main for-loop

	// operations to access 2D array
	POP {R12}
	MUL	R11, R7, R12	// R11 = floor * S (i * s)
	ADD R11, R11, R8	// R11 = (floor * s) + j

	SUB R10, =SECTION_MAX,

WHILE_LOOP_EXIT:
	BX LR

FIRST_LOOP_EXIT:

	BX LR

// 	PUSH {R14} // saves caller's link register

//	BL SUBROUTINE // call SUBROUTINE. LR(R14) now holds the return address

// 	POP {R14} // restore the original link register

//	BX LR // return from asm_func

//SUBROUTINE:

//	BX LR // return to the caller using the LR
